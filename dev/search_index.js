var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = LocalSearchSolvers","category":"page"},{"location":"#LocalSearchSolvers","page":"Home","title":"LocalSearchSolvers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [LocalSearchSolvers]","category":"page"},{"location":"#LocalSearchSolvers.Solver-Union{Tuple{Problem}, Tuple{T}} where T<:Number","page":"Home","title":"LocalSearchSolvers.Solver","text":"Solver{T}(p::Problem; values::Dictionary{Int,T}=Dictionary{Int,T}()) where T <: Number\nSolver{T}(;\n    variables::Dictionary{Int,Variable}=Dictionary{Int,Variable}(),\n    constraints::Dictionary{Int,Constraint}=Dictionary{Int,Constraint}(),\n    objectives::Dictionary{Int,Objective}=Dictionary{Int,Objective}(),\n    values::Dictionary{Int,T}=Dictionary{Int,T}(),\n) where T <: Number\n\nConstructor for a solver. Optional starting values can be provided.\n\n# Model a sudoku problem of size 4Ã—4\np = sudoku(2)\n\n# Create a solver instance with variables taking integral values\ns = Solver{Int}(p)\n\n# Solver with an empty problem to be filled later and expected Float64 values\ns = Solver{Float64}() \n\n# Construct a solver from a sets of constraints, objectives, and variables.\ns = Solver{Int}(\n    variables = get_constraints(p),\n    constraints = get_constraints(p),\n    objectives = get_objectives(p)\n) \n\n\n\n\n\n","category":"method"},{"location":"#LocalSearchSolvers.all_different-Tuple{Vararg{Int64,N} where N}","page":"Home","title":"LocalSearchSolvers.all_different","text":"all_different(x::Int...)\n\nGlobal constraint ensuring that all the values of x are unique.\n\n\n\n\n\n","category":"method"},{"location":"#LocalSearchSolvers.constraint-Union{Tuple{T}, Tuple{F}, Tuple{F,Array{Int64,1},Array{T,1}}} where T<:Real where F<:Function","page":"Home","title":"LocalSearchSolvers.constraint","text":"constraint(f::F, inds::Vector{Int}, values::Vector{T}) where {F <: Function,T <: Real}\nconstraint(f::F, inds::Vector{Int}, vars::Dictionary{Int,Variable}) where F <: Function\n\nTest the validity of f over a set of values or draw them from a set of variables vars. Return a constraint if the test is succesful, otherwise raise an error.\n\n\n\n\n\n","category":"method"},{"location":"#LocalSearchSolvers.describe-Tuple{Problem}","page":"Home","title":"LocalSearchSolvers.describe","text":"describe(p::Problem)\ndescribe(s::Solver)\n\nDescribe the model of either a Problem or a Solver.\n\n\n\n\n\n","category":"method"},{"location":"#LocalSearchSolvers.domain-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:Number","page":"Home","title":"LocalSearchSolvers.domain","text":"domain(values::Vector; domain = :set)\n\nDiscrete domain constructor. The type keyword can be set to :set (default) or :indices.\n\nd1 = domain([1,2,3,4], types = :indices)\nd2 = domain([53.69, 89.2, 0.12])\nd3 = domain([2//3, 89//123])\n\n\n\n\n\n","category":"method"},{"location":"#LocalSearchSolvers.solve!-Union{Tuple{Solver{T}}, Tuple{T}} where T<:Real","page":"Home","title":"LocalSearchSolvers.solve!","text":"solve!(s::Solver{T}; max_iteration=1000, verbose::Bool=false) where {T <: Real}\n\nRun the solver until a solution is found or max_iteration is reached.  verbose=true will print out details of the run.\n\n# Simply run the solver with default max_iteration\nsolve!(s)\n\n# Run indefinitely the solver with verbose behavior.\nsolve!(s, max_iteration = Inf, verbose = true)\n\n\n\n\n\n","category":"method"},{"location":"#LocalSearchSolvers.variable-Union{Tuple{D}, Tuple{D,String}} where D<:LocalSearchSolvers.AbstractDomain","page":"Home","title":"LocalSearchSolvers.variable","text":"variable(values::Vector{T}, name::String; domain = :set) where T <: Number\nvariable(domain::D, name::String) where D <: AbstractDomain\n\nConstruct a variable with discrete domain. See the domain method for other options.\n\nd = domain([1,2,3,4], types = :indices)\nx1 = variable(d, \"x1\")\nx2 = variable([-89,56,28], \"x2\", domain = :indices)\n\n\n\n\n\n","category":"method"}]
}
