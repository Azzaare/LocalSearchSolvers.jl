var documenterSearchIndex = {"docs":
[{"location":"d_constraint/#Constraints.jl","page":"Constraints.jl","title":"Constraints.jl","text":"","category":"section"},{"location":"d_constraint/","page":"Constraints.jl","title":"Constraints.jl","text":"A  back-end pacage for JuliaConstraints front packages, such as LocalSearchSolvers.jl.","category":"page"},{"location":"d_constraint/","page":"Constraints.jl","title":"Constraints.jl","text":"It provides the following features:","category":"page"},{"location":"d_constraint/","page":"Constraints.jl","title":"Constraints.jl","text":"A dictionary to store usual constraint: usual_contraint, which contains the following entries\n:all_different\n:dist_different\n:eq, :all_equal, :all_equal_param\n:ordered\n:always_true (mainly for testing default Constraint() constructor)\nFor each constraint c, the following properties\narguments length\nconcept (predicate the variables compliance with c)\nerror (a function that evaluate how much c is violated)\nparameters length\nknown symmetries of c\nA learning function using CompositionalNetworks.jl. If no error function is given when instanciating c, it will check the existence of a composition related to c and set the error to it.","category":"page"},{"location":"d_constraint/","page":"Constraints.jl","title":"Constraints.jl","text":"Follow the list of the constraints currently stored in usual_constraint. Note that if the constraint is named _my_constraint, it can be accessed as usual_contraint[:my_constraint].","category":"page"},{"location":"d_constraint/","page":"Constraints.jl","title":"Constraints.jl","text":"Constraints._all_different\nConstraints._all_equal\nConstraints._all_equal_param\nConstraints._dist_different\nConstraints._eq\nConstraints._ordered","category":"page"},{"location":"d_constraint/#Constraints._all_different","page":"Constraints.jl","title":"Constraints._all_different","text":"_all_different\n\nGlobal constraint ensuring that all the values of a given configuration are unique.\n\n\n\n\n\n","category":"constant"},{"location":"d_constraint/#Constraints._all_equal","page":"Constraints.jl","title":"Constraints._all_equal","text":"all_equal\n\nGlobal constraint ensuring that all the values of x are all equal.\n\n\n\n\n\n","category":"constant"},{"location":"d_constraint/#Constraints._all_equal_param","page":"Constraints.jl","title":"Constraints._all_equal_param","text":"all_equal_param\n\nGlobal constraint ensuring that all the values of x are all equal to a given parameter param.\n\n\n\n\n\n","category":"constant"},{"location":"d_constraint/#Constraints._dist_different","page":"Constraints.jl","title":"Constraints._dist_different","text":"dist_different\n\nLocal constraint ensuring that concept(dist_different, x) = |x[1] - x[2]| ≠ |x[3] - x[4]|).\n\n\n\n\n\n","category":"constant"},{"location":"d_constraint/#Constraints._eq","page":"Constraints.jl","title":"Constraints._eq","text":"_eq\n\nEquality between two variables.\n\n\n\n\n\n","category":"constant"},{"location":"d_constraint/#Constraints._ordered","page":"Constraints.jl","title":"Constraints._ordered","text":"ordered(x)\n\nGlobal constraint ensuring that all the values of x are ordered.\n\n\n\n\n\n","category":"constant"},{"location":"d_constraint/","page":"Constraints.jl","title":"Constraints.jl","text":"Modules = [Constraints]\nPrivate = false","category":"page"},{"location":"d_constraint/#Constraints.usual_constraints","page":"Constraints.jl","title":"Constraints.usual_constraints","text":"usual_constraints::Dict\n\nDictionary that contains all the usual constraints defined in Constraint.jl. \n\n\n\n\n\n","category":"constant"},{"location":"d_constraint/#Constraints.usual_symmetries","page":"Constraints.jl","title":"Constraints.usual_symmetries","text":"symmetries\n\nA Dictionary that contains the function to apply for each symmetry to avoid searching a whole space.\n\n\n\n\n\n","category":"constant"},{"location":"d_constraint/#Constraints.Constraint","page":"Constraints.jl","title":"Constraints.Constraint","text":"Constraint\n\nParametric stucture with the following fields.\n\nconcept: a Boolean function that, given an assignment x, outputs true if x satisfies the constraint, and false otherwise.\nerror: a positive function that works as preferences over invalid assignements. Return 0.0 if the constraint is satisfied, and a strictly positive real otherwise.\n\n\n\n\n\n","category":"type"},{"location":"d_constraint/#Constraints.args_length-Tuple{Constraints.Constraint}","page":"Constraints.jl","title":"Constraints.args_length","text":"args_length(c::Constraint)\n\nReturn the expected length restriction of the arguments in a constraint c. The value nothing indicates that any strictly positive number of value is accepted.\n\n\n\n\n\n","category":"method"},{"location":"d_constraint/#Constraints.concept-Tuple{Constraints.Constraint}","page":"Constraints.jl","title":"Constraints.concept","text":"concept(c::Constraint)\n\nReturn the concept (function) of constraint c.     concept(c::Constraint, x...; param = nothing) Apply the concept of c to values x and optionally param.\n\n\n\n\n\n","category":"method"},{"location":"d_constraint/#Constraints.error_f-Tuple{Constraints.Constraint}","page":"Constraints.jl","title":"Constraints.error_f","text":"error_f(c::Constraint)\n\nReturn the error function of constraint c.     error_f(c::Constraint, x; param = nothing) Apply the error function of c to values x and optionally param.\n\n\n\n\n\n","category":"method"},{"location":"d_constraint/#Constraints.params_length-Tuple{Constraints.Constraint}","page":"Constraints.jl","title":"Constraints.params_length","text":"params_length(c::Constraint)\n\nReturn the expected length restriction of the arguments in a constraint c. The value nothing indicates that any strictly positive number of parameters is accepted.\n\n\n\n\n\n","category":"method"},{"location":"d_constraint/#Constraints.symmetries-Tuple{Constraints.Constraint}","page":"Constraints.jl","title":"Constraints.symmetries","text":"symmetries(c::Constraint)\n\nReturn the list of symmetries of c.\n\n\n\n\n\n","category":"method"},{"location":"domain/#ConstraintDomains.jl","page":"ConstraintDomains.jl","title":"ConstraintDomains.jl","text":"","category":"section"},{"location":"domain/","page":"ConstraintDomains.jl","title":"ConstraintDomains.jl","text":"Currently only discrete domains are supported using the following function. ","category":"page"},{"location":"domain/","page":"ConstraintDomains.jl","title":"ConstraintDomains.jl","text":"ConstraintDomains.domain","category":"page"},{"location":"domain/#ConstraintDomains.domain","page":"ConstraintDomains.jl","title":"ConstraintDomains.domain","text":"domain(values::AbstractVector; type = :set)\n\nDiscrete domain constructor. The type keyword can be set to :set (default) or :indices.\n\nd1 = domain([1,2,3,4], type = :indices)\nd2 = domain([53.69, 89.2, 0.12])\nd3 = domain([2//3, 89//123])\n\n\n\n\n\n","category":"function"},{"location":"models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"LocalSearchSolvers.sudoku\nLocalSearchSolvers.golomb\nLocalSearchSolvers.cut","category":"page"},{"location":"icn/#CompositionalNetworks.jl","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"","category":"section"},{"location":"icn/","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"Pages = [\"public.md\"]\nDepth = 5","category":"page"},{"location":"icn/","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"CompositionalNetworks.jl, a Julia package for Interpretable Compositional Networks (ICN), a variant of neural networks, allowing the user to get interpretable results, unlike regular artificial neural networks.","category":"page"},{"location":"icn/","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"The current state of our ICN focuses on the composition of error functions for LocalSearchSolvers.jl, but produces results independently of it and export it to either/both Julia functions or/and human readable output.","category":"page"},{"location":"icn/#How-does-it-work?","page":"CompositionalNetworks.jl","title":"How does it work?","text":"","category":"section"},{"location":"icn/","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"The package comes with a basic ICN for learning global constraints. The ICN is composed of 4 layers: transformation, arithmetic, aggregation, and comparison. Each contains several operations that can be composed in various ways. Given a concept (a predicate over the variables' domains), a metric (hamming by default), and the variables' domains, we learn the binary weights of the ICN. ","category":"page"},{"location":"icn/#Installation","page":"CompositionalNetworks.jl","title":"Installation","text":"","category":"section"},{"location":"icn/","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"] add CompositionalNetworks","category":"page"},{"location":"icn/","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"As the package is in a beta version, some changes in the syntax and features are likely to occur. However, those changes should be minimal between minor versions. Please update with caution.","category":"page"},{"location":"icn/#Quickstart","page":"CompositionalNetworks.jl","title":"Quickstart","text":"","category":"section"},{"location":"icn/","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"# 4 variables in 1:4\ndoms = [domain([1,2,3,4]) for i in 1:4]\n\n# allunique concept (that is used to define the :all_different constraint)\nerr = explore_learn_compose(allunique, domains=doms)\n# > interpretation: identity ∘ count_positive ∘ sum ∘ count_eq_left\n\n# test our new error function\n@assert err([1,2,3,3], dom_size = 4) > 0.0\n\n# export an all_different function to file \"current/path/test_dummy.jl\" \ncompose_to_file!(icn, \"all_different\", \"test_dummy.jl\")","category":"page"},{"location":"icn/","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"The output file should produces a function that can be used as follows (assuming the maximum domain size is 7)","category":"page"},{"location":"icn/","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"import CompositionalNetworks\n\nall_different([1,2,3,4,5,6,7]; dom_size = 7)\n# > 0.0 (which means true, no errors)","category":"page"},{"location":"icn/","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"Please see JuliaConstraints/Constraints.jl/learn.jl for an extensive example of ICN learning and compositions.","category":"page"},{"location":"icn/#Public-interface","page":"CompositionalNetworks.jl","title":"Public interface","text":"","category":"section"},{"location":"icn/","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.jl","text":"Modules = [CompositionalNetworks]\nPrivate = false","category":"page"},{"location":"icn/#CompositionalNetworks.ICN","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.ICN","text":"ICN(; nvars, dom_size, param, transformation, arithmetic, aggregation, comparison)\n\nConstruct an Interpretable Compositional Network, with the following arguments:\n\nnvars: number of variable in the constraint\ndom_size: maximum domain size of any variable in the constraint\nparam: optional parameter (default to nothing)\ntransformation: a transformation layer (optional)\narithmetic: a arithmetic layer (optional)\naggregation: a aggregation layer (optional)\ncomparison: a comparison layer (optional)\n\n\n\n\n\n","category":"type"},{"location":"icn/#CompositionalNetworks.aggregation_layer-Tuple{}","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.aggregation_layer","text":"aggregation_layer()\n\nGenerate the layer of aggregations of the ICN. The operations are mutually exclusive, that is only one will be selected.\n\n\n\n\n\n","category":"method"},{"location":"icn/#CompositionalNetworks.arithmetic_layer-Tuple{}","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.arithmetic_layer","text":"arithmetic_layer()\n\nGenerate the layer of arithmetic operations of the ICN. The operations are mutually exclusive, that is only one will be selected.\n\n\n\n\n\n","category":"method"},{"location":"icn/#CompositionalNetworks.comparison_layer","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.comparison_layer","text":"comparison_layer(param = false)\n\nGenerate the layer of transformations functions of the ICN. Iff param value is set, also includes all the parametric comparison with that value. The operations are mutually exclusive, that is only one will be selected.\n\n\n\n\n\n","category":"function"},{"location":"icn/#CompositionalNetworks.compose-Tuple{ICN}","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.compose","text":"compose(icn)\ncompose(icn, weights)\n\nReturn a function composed by some of the operations of a given ICN. Can be applied to any vector of variables. If weights are given, will assign to icn.\n\n\n\n\n\n","category":"method"},{"location":"icn/#CompositionalNetworks.csv2space-Tuple{Any}","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.csv2space","text":"csv2space(file; filter=:none)\n\nConvert a csv file into a collection of configurations. If the filter is set to :concept, only solutions will be extracted.\n\n\n\n\n\n","category":"method"},{"location":"icn/#CompositionalNetworks.hamming-Tuple{Any,Any}","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.hamming","text":"hamming(x, X)\n\nCompute the hamming distance of x over a collection of solutions X, i.e. the minimal number of variables to switch in xto reach a solution.\n\n\n\n\n\n","category":"method"},{"location":"icn/#CompositionalNetworks.lazy-Tuple{Vararg{Function,N} where N}","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.lazy","text":"lazy(funcs::Function...)\n\nGenerate methods extended to a vector instead of one of its components. A function f should have the following signature: f(i::Int, x::V; param = nothing).\n\n\n\n\n\n","category":"method"},{"location":"icn/#CompositionalNetworks.lazy_param-Tuple{Vararg{Function,N} where N}","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.lazy_param","text":"lazy_param(funcs::Function...)\n\nGenerate methods extended to a vector instead of one of its components. A function f should have the following signature: f(i::Int, x::V; param).\n\n\n\n\n\n","category":"method"},{"location":"icn/#CompositionalNetworks.learn_compose","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.learn_compose","text":"learn_compose(;\n    nvars, dom_size, param=nothing, icn=ICN(nvars, dom_size, param),\n    X, X_sols, global_iter=100, local_iter=100, metric=hamming, popSize=200\n)\n\nCreate an ICN, optimize it, and return its composition.\n\n\n\n\n\n","category":"function"},{"location":"icn/#CompositionalNetworks.regularization-Tuple{Any}","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.regularization","text":"regularization(icn)\n\nReturn the regularization value of an ICN weights, which is proportional to the normalized number of operations selected in the icn layers.\n\n\n\n\n\n","category":"method"},{"location":"icn/#CompositionalNetworks.show_composition-Tuple{Any}","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.show_composition","text":"show_composition(icn)\n\nReturn the composition (weights) of an ICN.\n\n\n\n\n\n","category":"method"},{"location":"icn/#CompositionalNetworks.show_layers-Tuple{Any}","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.show_layers","text":"show_layers(icn)\n\nReturn a formated string with each layers in the icn.\n\n\n\n\n\n","category":"method"},{"location":"icn/#CompositionalNetworks.transformation_layer","page":"CompositionalNetworks.jl","title":"CompositionalNetworks.transformation_layer","text":"transformation_layer(param = false)\n\nGenerate the layer of transformations functions of the ICN. Iff param value is true, also includes all the parametric transformations.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Internal","page":"Internals","title":"Internal","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Pages = [\"internal.md\"]\nDepth = 5","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Modules = [LocalSearchSolvers]\nPublic = false","category":"page"},{"location":"internals/#LocalSearchSolvers.SudokuInstance","page":"Internals","title":"LocalSearchSolvers.SudokuInstance","text":"mutable struct SudokuInstance{T <: Integer} <: AbstractMatrix{T}\n\nA struct for SudokuInstances, which is a subtype of AbstractMatrix.\n\nSudokuInstance(A::AbstractMatrix{T})\nSudokuInstance(::Type{T}, n::Int) # fill in blank sudoku of type T\nSudokuInstance(n::Int) # fill in blank sudoku of type Int\nSudokuInstance(::Type{T}) # fill in \"standard\" 9×9 sudoku of type T\nSudokuInstance() # fill in \"standard\" 9×9 sudoku of type Int\nSudokuInstance(n::Int, P::Pair{Tuple{Int, Int}, T}...) where {T <: Integer} # construct a sudoku given pairs of coordinates and values\nSudokuInstance(P::Pair{Tuple{Int, Int}, T}...) # again, default to 9×9 sudoku, constructing given pairs\n\nConstructor functions for the SudokuInstance struct.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Base.Multimedia.display-Tuple{IO,LocalSearchSolvers.SudokuInstance}","page":"Internals","title":"Base.Multimedia.display","text":"display(io::IO, S::SudokuInstance)\ndisplay(S::SudokuInstance) # default to stdout\n\nDisplays an ntimes n SudokuInstance.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers.is_sat-Tuple{Model}","page":"Internals","title":"LocalSearchSolvers.is_sat","text":"is_sat(m::Model)\n\nReturn true if p is a satisfaction model.\n\n\n\n\n\n","category":"method"},{"location":"internals/#LocalSearchSolvers.is_specialized-Tuple{Model}","page":"Internals","title":"LocalSearchSolvers.is_specialized","text":"is_specialized(m::Model)\nis_specialized(s::Solver)\n\nReturn true if the model is already specialized.\n\n\n\n\n\n","category":"method"},{"location":"quickstart/#Quick-Start-Guide","page":"Quick Start Guide","title":"Quick Start Guide","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"This section introduce the main concepts of LocalSearchSolvers.jl. We model both a satisfaction and an optimization version of the Golomb Ruler problem.","category":"page"},{"location":"quickstart/#Golomb-Ruler","page":"Quick Start Guide","title":"Golomb Ruler","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"From Wikipedia's English page.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"In mathematics, a Golomb ruler is a set of marks at integer positions along an imaginary ruler such that no two pairs of marks are the same distance apart. The number of marks on the ruler is its order, and the largest distance between two of its marks is its length. Translation and reflection of a Golomb ruler are considered trivial, so the smallest mark is customarily put at 0 and the next mark at the smaller of its two possible values.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"(Image: )","category":"page"},{"location":"quickstart/#Satisfaction-version","page":"Quick Start Guide","title":"Satisfaction version","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Given a number of marks n and a ruler length L, we can model our problem in Julia as easily as follows. First create an empty problem.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"model = Model()","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Then add n variables with domain d.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"d = domain(0:L)\nforeach(_ -> variable!(model, d), 1:n)","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Finally add the following constraints,","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"all marks have a different value\nfirst mark has value 0\nfinally, no two pairs of marks are the same distance appart","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"constraint!(model, c_all_different, 1:n)\nconstraint!(model, x -> c_all_equal_param(x; param = 0), 1:1)\nfor i in 1:(n - 1), j in (i + 1):n, k in i:(n - 1), l in (k + 1):n\n    (i, j) < (k, l) || continue\n    constraint!(model, c_dist_different, [i, j, k, l])\nend","category":"page"},{"location":"quickstart/#Optimization-version","page":"Quick Start Guide","title":"Optimization version","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"A Golomb ruler can be either optimally dense (maximal m for a given L) or optimally short (minimal L for a given n). Until LocalSearchSolvers.jl implements dynamic problems, only optimal shortness is provided.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"The model objective is then to minimize the maximum distance between the two extrema marks in the ruler.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"objective!(model, o_dist_extrema)","category":"page"},{"location":"quickstart/#Ruling-the-solver","page":"Quick Start Guide","title":"Ruling the solver","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"For either version, the solver is built and run in a similar way. Please note that the satisfaction one will stop if a solution is found. The other will run until the maximum number of iteration is reached.","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"s = Solver(model)\nsolve!(s)","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"And finally retrieve the (best-known) solution info. (TODO: make it julian and clean)","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"@info \"Results golomb!\"\n@info \"Values: $(s.state.values)\"\n@info \"Sol (val): $(s.state.best_solution_value)\"\n@info \"Sol (vals): $(!isnothing(s.state.best_solution_value) ? s.state.best_solution : nothing)\"","category":"page"},{"location":"quickstart/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Please note, that the Golomb Ruler is already implemented in the package as golomb(n::Int, L::Int=n^2). An hand-made printing function is also there: TODO:.","category":"page"},{"location":"public/#Public","page":"Public","title":"Public","text":"","category":"section"},{"location":"public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]\nDepth = 5","category":"page"},{"location":"public/","page":"Public","title":"Public","text":"Modules = [LocalSearchSolvers]\nPrivate = false","category":"page"},{"location":"public/#LocalSearchSolvers.Solver-Union{Tuple{Model}, Tuple{T}, Tuple{Model,Dict{Symbol,Any}}} where T<:Number","page":"Public","title":"LocalSearchSolvers.Solver","text":"Solver{T}(m::Model; values::Dictionary{Int,T}=Dictionary{Int,T}()) where T <: Number\nSolver{T}(;\n    variables::Dictionary{Int,Variable}=Dictionary{Int,Variable}(),\n    constraints::Dictionary{Int,Constraint}=Dictionary{Int,Constraint}(),\n    objectives::Dictionary{Int,Objective}=Dictionary{Int,Objective}(),\n    values::Dictionary{Int,T}=Dictionary{Int,T}(),\n) where T <: Number\n\nConstructor for a solver. Optional starting values can be provided.\n\n# Model a sudoku model of size 4×4\nm = sudoku(2)\n\n# Create a solver instance with variables taking integral values\ns = Solver{Int}(m)\n\n# Solver with an empty model to be filled later and expected Float64 values\ns = Solver{Float64}()\n\n# Construct a solver from a sets of constraints, objectives, and variables.\ns = Solver{Int}(\n    variables = get_constraints(m),\n    constraints = get_constraints(m),\n    objectives = get_objectives(m)\n)\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.constraint-Union{Tuple{F}, Tuple{T}, Tuple{F,AbstractArray{Int64,1},AbstractArray{T,1}}} where F<:Function where T<:Number","page":"Public","title":"LocalSearchSolvers.constraint","text":"constraint(f::F, inds::Vector{Int}, values::Vector{T}) where {F <: Function,T <: Number}\nconstraint(f::F, inds::Vector{Int}, vars::Dictionary{Int,Variable}) where F <: Function\n\nTest the validity of f over a set of values or draw them from a set of variables vars. Return a constraint if the test is succesful, otherwise raise an error.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.describe-Tuple{Model}","page":"Public","title":"LocalSearchSolvers.describe","text":"describe(m::Model)\ndescribe(s::AbstractSolver)\n\nDescribe the model of either a Model or a Solver.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.o_dist_extrema-Tuple{Any}","page":"Public","title":"LocalSearchSolvers.o_dist_extrema","text":"dist_extrema(values::T...) where {T <: Number}\n\nComputes the distance between extrema in an ordered set.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.o_mincut-Tuple{Any,Any}","page":"Public","title":"LocalSearchSolvers.o_mincut","text":"o_mincut(graph, values; interdiction = 0)\n\nCompute the capacity of a cut (determined by the state of the solver) with a possible interdiction on the highest capacited links.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.solve!-Tuple{Solver}","page":"Public","title":"LocalSearchSolvers.solve!","text":"solve!(s::Solver{T}; max_iteration=1000, verbose::Bool=false) where {T <: Real}\n\nRun the solver until a solution is found or max_iteration is reached. verbose=true will print out details of the run.\n\n# Simply run the solver with default max_iteration\nsolve!(s)\n\n# Run indefinitely the solver with verbose behavior.\nsolve!(s, max_iteration = Inf, verbose = true)\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.specialize-Tuple{Model}","page":"Public","title":"LocalSearchSolvers.specialize","text":"specialize(m::Model)\nspecialize(s::Solver)\n\nSpecialize the structure of a model to avoid dynamic type attribution at runtime.\n\n\n\n\n\n","category":"method"},{"location":"public/#LocalSearchSolvers.variable-Tuple{AbstractDomain,AbstractString}","page":"Public","title":"LocalSearchSolvers.variable","text":"variable(values::AbstractVector{T}, name::AbstractString; domain = :set) where T <: Number\nvariable(domain::AbstractDomain, name::AbstractString) where D <: AbstractDomain\n\nConstruct a variable with discrete domain. See the domain method for other options.\n\nd = domain([1,2,3,4], types = :indices)\nx1 = variable(d, \"x1\")\nx2 = variable([-89,56,28], \"x2\", domain = :indices)\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = LocalSearchSolvers","category":"page"},{"location":"#Constraint-Based-Local-Search","page":"Home","title":"Constraint-Based Local Search","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LocalSearchSolvers.jl proposes sets of technical components of Constraint-Based Local Search (CBLS) solvers and combine them in various ways.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<!– TODO: what is a CBLS solver etc. –>","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Dependencies","page":"Home","title":"Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package makes use of several dependencies from the JuliaConstraints GitHub org:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ConstraintDomains.jl: a domains back-end package for all JuliaConstraints front packages\nConstraints.jl: a constraints back-end package for all JuliaConstraints front packages\nCompositionalNetworks.jl: a module to learn error functions automatically given a concept\nGaramon.jl (incoming): geometrical constraints","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[ ] Resolution of problems\n[x] SATisfaction\n[x] OPTimisation (single-objective)\n[ ] OPTimisation (multiple-objective)\n[ ] Domains\n[x] Discrete domains (any type of numbers)\n[ ] Continuous domains\n[ ] Arbitrary Objects such as physical ones\n[ ] Parallelization\n[ ] Multithreading\n[ ] Distributed\n[ ] Solvers\n[x] Weak-tabu list (based on the method in GHOST, the C++ lib)\n[ ] Adaptive Search\n[ ] Domain Specific Languages (DSL)\n[x] Straight Julia\n[ ] JuMPish\n[ ] MiniZinc\n[ ] Others\n[ ] Dynamic problems\n[ ] Neighbourhoud selection\n[ ] Variable selection\n[ ] Mixed-solvers/methods with learning ","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions to this package are more than welcome and can be arbitrarily, and not exhaustively, split as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"All features mentioned above\nAdding new constraints and symmetries\nAdding new ICNs to learn error of existing constraints\nCreating other compositional networks which target other kind of constraints\nJust making stuff better, faster, user-friendlier, etc.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Do not hesitate to contact me (@azzaare) or other members of JuliaConstraints on GitHub (file an issue), the julialang discourse forum, the julialang slack channel, the julialang zulip server, or the Human of Julia (HoJ) discord server.","category":"page"}]
}
