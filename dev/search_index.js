var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = LocalSearchSolvers","category":"page"},{"location":"#LocalSearchSolvers","page":"Home","title":"LocalSearchSolvers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [LocalSearchSolvers]","category":"page"},{"location":"#LocalSearchSolvers.Solver-Union{Tuple{Problem}, Tuple{T}} where T<:Number","page":"Home","title":"LocalSearchSolvers.Solver","text":"Solver{T}(p::Problem; values::Dictionary{Int,T}=Dictionary{Int,T}()) where T <: Number\nSolver{T}(;\n    variables::Dictionary{Int,Variable}=Dictionary{Int,Variable}(),\n    constraints::Dictionary{Int,Constraint}=Dictionary{Int,Constraint}(),\n    objectives::Dictionary{Int,Objective}=Dictionary{Int,Objective}(),\n    values::Dictionary{Int,T}=Dictionary{Int,T}(),\n) where T <: Number\n\nConstructor for a solver. Optional starting values can be provided.\n\n# Model a sudoku problem of size 4Ã—4\np = sudoku(2)\n\n# Create a solver instance with variables taking integral values\ns = Solver{Int}(p)\n\n# Solver with an empty problem to be filled later and expected Float64 values\ns = Solver{Float64}()\n\n# Construct a solver from a sets of constraints, objectives, and variables.\ns = Solver{Int}(\n    variables = get_constraints(p),\n    constraints = get_constraints(p),\n    objectives = get_objectives(p)\n)\n\n\n\n\n\n","category":"method"},{"location":"#LocalSearchSolvers.all_different-Tuple{Vararg{Int64,N} where N}","page":"Home","title":"LocalSearchSolvers.all_different","text":"all_different(x::Int...)\n\nGlobal constraint ensuring that all the values of x are unique.\n\n\n\n\n\n","category":"method"},{"location":"#LocalSearchSolvers.constraint-Union{Tuple{F}, Tuple{T}, Tuple{F,AbstractArray{Int64,1},AbstractArray{T,1}}} where F<:Function where T<:Number","page":"Home","title":"LocalSearchSolvers.constraint","text":"constraint(f::F, inds::Vector{Int}, values::Vector{T}) where {F <: Function,T <: Number}\nconstraint(f::F, inds::Vector{Int}, vars::Dictionary{Int,Variable}) where F <: Function\n\nTest the validity of f over a set of values or draw them from a set of variables vars. Return a constraint if the test is succesful, otherwise raise an error.\n\n\n\n\n\n","category":"method"},{"location":"#LocalSearchSolvers.describe-Tuple{Problem}","page":"Home","title":"LocalSearchSolvers.describe","text":"describe(p::Problem)\ndescribe(s::AbstractSolver)\n\nDescribe the model of either a Problem or a Solver.\n\n\n\n\n\n","category":"method"},{"location":"#LocalSearchSolvers.domain-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T<:Number","page":"Home","title":"LocalSearchSolvers.domain","text":"domain(values::AbstractVector; type = :set)\n\nDiscrete domain constructor. The type keyword can be set to :set (default) or :indices.\n\nd1 = domain([1,2,3,4], type = :indices)\nd2 = domain([53.69, 89.2, 0.12])\nd3 = domain([2//3, 89//123])\n\n\n\n\n\n","category":"method"},{"location":"#LocalSearchSolvers.is_sat-Tuple{Problem}","page":"Home","title":"LocalSearchSolvers.is_sat","text":"is_sat(p::Problem)\n\nReturn true if p is a satisfaction problem.\n\n\n\n\n\n","category":"method"},{"location":"#LocalSearchSolvers.is_specialized-Tuple{Problem}","page":"Home","title":"LocalSearchSolvers.is_specialized","text":"is_specialized(p::Problem)\nis_specialized(s::Solver)\n\nReturn true if the problem is already specialized.\n\n\n\n\n\n","category":"method"},{"location":"#LocalSearchSolvers.solve!-Tuple{Solver}","page":"Home","title":"LocalSearchSolvers.solve!","text":"solve!(s::Solver{T}; max_iteration=1000, verbose::Bool=false) where {T <: Real}\n\nRun the solver until a solution is found or max_iteration is reached. verbose=true will print out details of the run.\n\n# Simply run the solver with default max_iteration\nsolve!(s)\n\n# Run indefinitely the solver with verbose behavior.\nsolve!(s, max_iteration = Inf, verbose = true)\n\n\n\n\n\n","category":"method"},{"location":"#LocalSearchSolvers.specialize-Tuple{Problem}","page":"Home","title":"LocalSearchSolvers.specialize","text":"specialize(p::Problem)\nspecialize(s::Solver)\n\nSpecialize the structure of a problem to avoid dynamic type attribution at runtime.\n\n\n\n\n\n","category":"method"},{"location":"#LocalSearchSolvers.variable-Tuple{LocalSearchSolvers.AbstractDomain,AbstractString}","page":"Home","title":"LocalSearchSolvers.variable","text":"variable(values::AbstractVector{T}, name::AbstractString; domain = :set) where T <: Number\nvariable(domain::AbstractDomain, name::AbstractString) where D <: AbstractDomain\n\nConstruct a variable with discrete domain. See the domain method for other options.\n\nd = domain([1,2,3,4], types = :indices)\nx1 = variable(d, \"x1\")\nx2 = variable([-89,56,28], \"x2\", domain = :indices)\n\n\n\n\n\n","category":"method"}]
}
